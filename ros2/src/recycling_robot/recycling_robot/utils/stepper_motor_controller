#!/usr/bin/env python3
"""
Stepper motor controller optimized for A4988 driver
Replacement for DC motor controller in recycling robot
"""
import time
import os
import threading
import math
from contextlib import contextmanager
from typing import Optional, Tuple

class StepperMotorController:
    """High-performance stepper motor controller for A4988 driver"""
    
    def __init__(self):
        # A4988 Driver pins (reusing some old pins)
        self.DIR_PIN = 17     # Was IN2_PIN - sets direction
        self.STEP_PIN = 27    # Was IN1_PIN - generates step pulses
        self.EN_PIN = 22      # Was ENA_PIN - enables/disables driver
        
        # Optional additional pins for A4988
        self.MS1_PIN = None   # Microstep resolution pins
        self.MS2_PIN = None   # (can be hardwired on driver board)
        self.MS3_PIN = None
        self.RESET_PIN = None # Can tie to VCC if not used
        self.SLEEP_PIN = None # Can tie to VCC if not used
        
        # Stepper motor specifications
        self.STEPS_PER_REV = 200  # 1.8Â° per step typical NEMA17
        self.MICROSTEPS = 1       # 1=full step, 2=half, 4,8,16 available
        self.MAX_SPEED_RPM = 300  # Maximum safe RPM
        self.DEFAULT_SPEED_RPM = 60
        
        # State management
        self.current_position = 0  # Steps from home
        self.is_enabled = False
        self.gpio_lib = None
        self.gpio_handle = None
        
        # Threading for smooth motion
        self.motion_thread = None
        self.motion_running = False
        self._motion_lock = threading.Lock()
        
        # Performance tracking
        self.last_command_time = 0
        
        # Initialize GPIO with fallback hierarchy
        self._initialize_gpio()
        
        # Initialize stepper to disabled state
        self.disable()
        print(f"[StepperController] Initialized with {self.gpio_lib} backend")
        print(f"[StepperController] Steps per revolution: {self.STEPS_PER_REV}")
        print(f"[StepperController] Microsteps: {self.MICROSTEPS}")
    
    def _initialize_gpio(self):
        """Initialize GPIO with multiple fallback options"""
        
        # Method 1: lgpio (fastest, most reliable in containers)
        if self._try_lgpio():
            return
            
        # Method 2: RPi.GPIO with memory access fix
        if self._try_rpi_gpio():
            return
            
        # Method 3: Direct sysfs GPIO (always works, decent performance)
        if self._try_sysfs_gpio():
            return
            
        # Method 4: gpiozero (higher level, good fallback)
        if self._try_gpiozero():
            return
            
        # Final fallback: mock GPIO
        self._create_mock_gpio()
    
    def _try_lgpio(self) -> bool:
        """Try modern lgpio library"""
        try:
            import lgpio
            
            # Open GPIO chip
            self.gpio_handle = lgpio.gpiochip_open(0)
            
            # Test GPIO access by claiming pins
            lgpio.gpio_claim_output(self.gpio_handle, self.STEP_PIN)
            lgpio.gpio_claim_output(self.gpio_handle, self.DIR_PIN)
            lgpio.gpio_claim_output(self.gpio_handle, self.EN_PIN)
            
            self.gpio_lib = 'lgpio'
            print(f"[StepperController] Using lgpio - GPIO pins {self.STEP_PIN}, {self.DIR_PIN}, {self.EN_PIN}")
            return True
            
        except (ImportError, Exception) as e:
            print(f"[StepperController] lgpio failed: {e}")
            return False
    
    def _try_rpi_gpio(self) -> bool:
        """Try RPi.GPIO with Docker compatibility fixes"""
        try:
            import RPi.GPIO as GPIO
            
            # Force GPIO memory mapping for Docker containers
            if os.path.exists('/dev/gpiomem'):
                os.environ['GPIOMEM'] = '1'
            
            # Try different GPIO modes for container compatibility
            try:
                GPIO.setmode(GPIO.BCM)
            except RuntimeError:
                # If SOC detection fails, try manual setup
                GPIO.setmode(GPIO.BOARD)
                GPIO.setmode(GPIO.BCM)
            
            # Setup pins
            GPIO.setup(self.STEP_PIN, GPIO.OUT)
            GPIO.setup(self.DIR_PIN, GPIO.OUT)
            GPIO.setup(self.EN_PIN, GPIO.OUT)
            
            self.gpio_lib = 'RPi.GPIO'
            print(f"[StepperController] Using RPi.GPIO - GPIO pins {self.STEP_PIN}, {self.DIR_PIN}, {self.EN_PIN}")
            return True
            
        except (ImportError, Exception) as e:
            print(f"[StepperController] RPi.GPIO failed: {e}")
            return False
    
    def _try_sysfs_gpio(self) -> bool:
        """Try direct sysfs GPIO access (works in any container)"""
        try:
            # Export GPIO pins via sysfs
            for pin in [self.STEP_PIN, self.DIR_PIN, self.EN_PIN]:
                if not os.path.exists(f'/sys/class/gpio/gpio{pin}'):
                    with open('/sys/class/gpio/export', 'w') as f:
                        f.write(str(pin))
                
                # Set as output
                with open(f'/sys/class/gpio/gpio{pin}/direction', 'w') as f:
                    f.write('out')
            
            self.gpio_lib = 'sysfs'
            print(f"[StepperController] Using sysfs GPIO - GPIO pins {self.STEP_PIN}, {self.DIR_PIN}, {self.EN_PIN}")
            return True
            
        except (PermissionError, OSError, Exception) as e:
            print(f"[StepperController] sysfs GPIO failed: {e}")
            return False
    
    def _try_gpiozero(self) -> bool:
        """Try gpiozero library (good high-level fallback)"""
        try:
            from gpiozero import OutputDevice
            
            self.step_device = OutputDevice(self.STEP_PIN)
            self.dir_device = OutputDevice(self.DIR_PIN)
            self.en_device = OutputDevice(self.EN_PIN)
            
            self.gpio_lib = 'gpiozero'
            print(f"[StepperController] Using gpiozero - GPIO pins {self.STEP_PIN}, {self.DIR_PIN}, {self.EN_PIN}")
            return True
            
        except (ImportError, Exception) as e:
            print(f"[StepperController] gpiozero failed: {e}")
            return False
    
    def _create_mock_gpio(self):
        """Create mock GPIO for testing"""
        self.gpio_lib = 'mock'
        self.gpio_handle = None
        print("[StepperController] Using mock GPIO - motor will not move")
        print("[StepperController] WARNING: Physical stepper will NOT move!")
    
    def _set_pin_state(self, pin: int, state: bool):
        """Set GPIO pin state using active backend"""
        if self.gpio_lib == 'lgpio':
            import lgpio
            lgpio.gpio_write(self.gpio_handle, pin, 1 if state else 0)
            
        elif self.gpio_lib == 'RPi.GPIO':
            import RPi.GPIO as GPIO
            GPIO.output(pin, state)
            
        elif self.gpio_lib == 'sysfs':
            try:
                with open(f'/sys/class/gpio/gpio{pin}/value', 'w') as f:
                    f.write('1' if state else '0')
            except Exception:
                pass  # Ignore write errors for robustness
                
        elif self.gpio_lib == 'gpiozero':
            if pin == self.STEP_PIN:
                device = self.step_device
            elif pin == self.DIR_PIN:
                device = self.dir_device
            elif pin == self.EN_PIN:
                device = self.en_device
            else:
                return
                
            if state:
                device.on()
            else:
                device.off()
                
        else:  # mock
            pin_names = {self.STEP_PIN: 'STEP', self.DIR_PIN: 'DIR', self.EN_PIN: 'EN'}
            pin_name = pin_names.get(pin, f'GPIO{pin}')
            print(f"[MockGPIO] {pin_name}={'HIGH' if state else 'LOW'}")
    
    def enable(self):
        """Enable the stepper driver (EN pin LOW for A4988)"""
        self._set_pin_state(self.EN_PIN, False)  # A4988: LOW = enabled
        self.is_enabled = True
        print("[StepperController] Driver enabled")
    
    def disable(self):
        """Disable the stepper driver (EN pin HIGH for A4988)"""
        self._set_pin_state(self.EN_PIN, True)   # A4988: HIGH = disabled
        self.is_enabled = False
        print("[StepperController] Driver disabled")
    
    def _calculate_step_delay(self, rpm: float) -> float:
        """Calculate delay between steps for given RPM"""
        if rpm <= 0:
            return 0.1  # Very slow fallback
        
        # Steps per second = (RPM * steps_per_rev * microsteps) / 60
        steps_per_second = (rpm * self.STEPS_PER_REV * self.MICROSTEPS) / 60.0
        
        # Delay between steps (seconds)
        step_delay = 1.0 / steps_per_second / 2.0  # Divide by 2 for pulse timing
        
        return max(step_delay, 0.0001)  # Minimum 0.1ms delay
    
    def _make_steps(self, steps: int, rpm: float = None, clockwise: bool = True):
        """Generate the specified number of steps"""
        if not self.is_enabled:
            print("[StepperController] Driver not enabled, call enable() first")
            return
            
        if steps <= 0:
            return
            
        rpm = rpm or self.DEFAULT_SPEED_RPM
        step_delay = self._calculate_step_delay(rpm)
        
        # Set direction
        self._set_pin_state(self.DIR_PIN, clockwise)
        time.sleep(0.001)  # Small delay for direction setup
        
        print(f"[StepperController] Making {steps} steps at {rpm} RPM ({'CW' if clockwise else 'CCW'})")
        
        # Generate step pulses
        for i in range(steps):
            # Pulse high
            self._set_pin_state(self.STEP_PIN, True)
            time.sleep(step_delay)
            
            # Pulse low
            self._set_pin_state(self.STEP_PIN, False)
            time.sleep(step_delay)
            
            # Update position
            if clockwise:
                self.current_position += 1
            else:
                self.current_position -= 1
    
    def rotate_degrees(self, degrees: float, rpm: float = None, clockwise: bool = True):
        """Rotate by specified degrees"""
        # Calculate steps needed
        steps_needed = abs(int((degrees / 360.0) * self.STEPS_PER_REV * self.MICROSTEPS))
        
        if degrees < 0:
            clockwise = not clockwise
            
        self._make_steps(steps_needed, rpm, clockwise)
    
    def rotate_revolutions(self, revolutions: float, rpm: float = None, clockwise: bool = True):
        """Rotate by specified revolutions"""
        # Calculate steps needed
        steps_needed = abs(int(revolutions * self.STEPS_PER_REV * self.MICROSTEPS))
        
        if revolutions < 0:
            clockwise = not clockwise
            
        self._make_steps(steps_needed, rpm, clockwise)
    
    def step_to_position(self, target_position: int, rpm: float = None):
        """Move to absolute step position"""
        steps_to_move = target_position - self.current_position
        
        if steps_to_move == 0:
            return
            
        clockwise = steps_to_move > 0
        steps_needed = abs(steps_to_move)
        
        self._make_steps(steps_needed, rpm, clockwise)
    
    # Compatibility methods with old DC motor interface
    def forward(self, speed: float = 0.8, duration: Optional[float] = None):
        """Move motor forward (clockwise) - compatibility with DC motor interface"""
        start_time = time.time()
        
        # Map speed (0-1) to RPM
        rpm = speed * self.MAX_SPEED_RPM
        
        print(f"[StepperController] Moving forward at {rpm:.1f} RPM")
        
        if not self.is_enabled:
            self.enable()
        
        if duration:
            # Calculate steps for the duration
            steps_in_duration = int((rpm * self.STEPS_PER_REV * self.MICROSTEPS * duration) / 60.0)
            self._make_steps(steps_in_duration, rpm, clockwise=True)
        else:
            # For recycling robot: make 1 full revolution by default
            self.rotate_revolutions(1.0, rpm, clockwise=True)
        
        # Track response time
        self.last_command_time = (time.time() - start_time) * 1000
    
    def backward(self, speed: float = 0.8, duration: Optional[float] = None):
        """Move motor backward (counter-clockwise) - compatibility with DC motor interface"""
        start_time = time.time()
        
        # Map speed (0-1) to RPM
        rpm = speed * self.MAX_SPEED_RPM
        
        print(f"[StepperController] Moving backward at {rpm:.1f} RPM")
        
        if not self.is_enabled:
            self.enable()
        
        if duration:
            # Calculate steps for the duration
            steps_in_duration = int((rpm * self.STEPS_PER_REV * self.MICROSTEPS * duration) / 60.0)
            self._make_steps(steps_in_duration, rpm, clockwise=False)
        else:
            # For recycling robot: make 1 full revolution by default
            self.rotate_revolutions(1.0, rpm, clockwise=False)
        
        # Track response time
        self.last_command_time = (time.time() - start_time) * 1000
    
    def stop(self):
        """Stop motor immediately"""
        start_time = time.time()
        
        print("[StepperController] Motor stop")
        
        # For stepper motors, stopping just means not sending more step pulses
        # The motor will hold position if enabled
        
        # Optionally disable to save power
        # self.disable()  # Uncomment if you want to disable on stop
        
        # Track response time
        self.last_command_time = (time.time() - start_time) * 1000
    
    def home(self, rpm: float = None):
        """Return to home position (step 0)"""
        print("[StepperController] Homing...")
        self.step_to_position(0, rpm)
        print("[StepperController] Homing complete")
    
    def get_status(self) -> dict:
        """Get stepper motor controller status for diagnostics"""
        return {
            'gpio_library': self.gpio_lib,
            'is_mock': self.gpio_lib == 'mock',
            'pins': {
                'STEP': self.STEP_PIN,
                'DIR': self.DIR_PIN,
                'EN': self.EN_PIN
            },
            'motor_specs': {
                'steps_per_rev': self.STEPS_PER_REV,
                'microsteps': self.MICROSTEPS,
                'max_speed_rpm': self.MAX_SPEED_RPM
            },
            'current_position_steps': self.current_position,
            'current_position_degrees': (self.current_position / (self.STEPS_PER_REV * self.MICROSTEPS)) * 360,
            'is_enabled': self.is_enabled,
            'last_response_time_ms': self.last_command_time
        }
    
    def cleanup(self):
        """Clean up GPIO resources"""
        try:
            self.disable()
            
            if self.gpio_lib == 'lgpio':
                import lgpio
                lgpio.gpiochip_close(self.gpio_handle)
                
            elif self.gpio_lib == 'RPi.GPIO':
                import RPi.GPIO as GPIO
                GPIO.cleanup()
                
            elif self.gpio_lib == 'sysfs':
                # Unexport GPIO pins
                for pin in [self.STEP_PIN, self.DIR_PIN, self.EN_PIN]:
                    try:
                        if os.path.exists(f'/sys/class/gpio/gpio{pin}'):
                            with open('/sys/class/gpio/unexport', 'w') as f:
                                f.write(str(pin))
                    except Exception:
                        pass
                        
            elif self.gpio_lib == 'gpiozero':
                self.step_device.close()
                self.dir_device.close()
                self.en_device.close()
            
            print("[StepperController] GPIO cleanup completed")
            
        except Exception as e:
            print(f"[StepperController] Cleanup error: {e}")


# Test and benchmark function
def benchmark_stepper_controller():
    """Benchmark stepper motor controller performance"""
    print("[Benchmark] Testing stepper motor controller...")
    
    motor = StepperMotorController()
    
    try:
        status = motor.get_status()
        print(f"[Benchmark] Status: {status}")
        
        if status['is_mock']:
            print("[Benchmark] WARNING: Running in mock mode!")
        
        # Test basic movements
        print("[Benchmark] Testing movements...")
        
        motor.enable()
        time.sleep(0.5)
        
        # Test forward movement (like recycling robot)
        motor.forward(0.8, 1.0)  # 80% speed for 1 second
        time.sleep(0.5)
        
        # Test positioning
        motor.rotate_degrees(90)  # Quarter turn
        time.sleep(0.5)
        
        motor.home()  # Return home
        
        final_status = motor.get_status()
        print(f"[Benchmark] Final position: {final_status['current_position_steps']} steps")
        
    finally:
        motor.cleanup()


# Alias for backward compatibility
MotorController = StepperMotorController

if __name__ == "__main__":
    benchmark_stepper_controller()